# Known Caveats Of Polyjuice

When designing and building polyjuice, we aim at the highest level of compatibility, meaning:

* EVM used in polyjuice shall be 100% compatible with latest fork version of Ethereum;
* Via a [Web3 translation layer](https://github.com/bitrocks/godwoken-web3), polyjuice shall be 100% compatible with Ethereum with respect to RPCs

However, due to drastically different architecture and design considerations, there will inevitably be some differences when working on polyjuice. This article aims at document and communicate such caveats.

## Account Creation

One must create an account on a godwoken chain, in order to use polyjuice on this godwoken chain. The only way to create an account now, is depositing funds into godwoken.

The operation would fail if one simply transfers tokens to a godwoken address that has not been created. The problem here, is a lack of information: Ethereum only provides 20 bytes of space for a receiver account, we cannot pack all the information required to create a godwoken account in 20 bytes.

## pETH

pETH is a fixed sUDT token type chosen when deploying a polyjuice chain. A pETH token type to a polyjuice chain, is like ETH to the Ethereum chain: it is used as the native token used to charge transaction fees. The gas price of polyjuice transactions, is measured using pETH for the designated polyjuice chain, which will be deducted from sender's account when the transaction is committed on chain. Different polyjuice chain might use different token type as pETH: while one polyjuice chain might use CKB as pETH, another polyjuice chain might choose to use a different sUDT type(for example, one can map native ETH tokens to CKB's sUDT via force bridge) as pETH.

Note that a godwoken chain might contain multiple polyjuice chain, each polyjuice chain is denoted by the "creator account", much like the `0x0000 ... 0000` address on Ethereum. Different pETH token types might be used for different polyjuice chains, even though they might all coexist on the same godwoken chain.

## All Tokens Are ERC20 Tokens

Ethereum differs in the processing of ERC20 tokens, and native ETH tokens. This is also the reason why wETH is invented. Godwoken hides this differences underneath: no matter if you are using native CKB or any sUDT token type, they will all be represented as a single layer 2 sUDT type in godwoken. Polyjuice starts from this single layer 2 sUDT type, and ensures that all tokens on godwoken, whether they are backed by native CKB or sUDT, confront to the ERC20 standard. This means you don't have to distinguish between native token and ERC20 tokens. All you have to deal with, is the same ERC20 interface for all different types of tokens.

## Polyjuice Address vs Ethereum Address

Polyjuice address is the biggest, and the most controversial change introduced by polyjuice. We strongly recommend you to read this section carefully, and make sure you understand the caveats involved here.

For every blockchain out there, 2 individual components exist:

* Identity check: how can the blockchain check the owner of an on-chain account? Typically, this is performed via digital signature verification.
* Computation / Verification(depending on how you approach the problem): how does one transaction affect the on-chain state?

Ethereum, like many other blockchains of its age, coupled the 2 components together. But at Nervos, we believe the power of [interoperability](https://talk.nervos.org/t/blockchain-abstraction-and-interoperability-2-0/5440). In the design of godwoken, identity check and on-chain computation are totally decoupled and separated, which unleashes new potentials:

* An Ethereum app can be used not only via Ethereum wallets such as MetaMask, but also Tron, EOS, BTC or other wallets.
* An Etheruem wallet can work on not only Ethereum apps, but also [diem](https://www.diem.com/en-us/) or other blockchain apps.

In this world, a user can interact with numerous apps via a single wallet and a single address, while a dapp is open to users using different wallets via a single deployment. Long gone the hassles of having one address/wallet per blockchain.

But this wish also comes with a price: Ethereum uses 20 byte address format at both identity and computation side. This is fine for Ethereum, since it couples ideneity check with computation. In godwoken we would want something different: not only Ethereum address, but also Tron, EOS, BTC, CKB or other addresses can all be used as identity. We need to pack all those different addresses in a 20 byte address space at polyjuice computation side. If we continue to use the full 20 bytes of Ethereum address in polyjuice, we won't have space for addresses generated by all the other blockchains.

For this consideration, we have to introduce the concept of polyjuice address here. And distinguish between polyjuice address and identity address:

* An identity address is the address created in a blockchain wallet for a user, it could be an Ethereum address, a Tron address, an EOS address, a BTC address, a CKB address or addresses from other supported blockchains.
* A polyjuice address is the internal address used by polyjuice, it is also of 20 bytes long like an Ethereum address, but it differs from an Ethereum identity address.

A polyjuice address is unique to a godwoken chain, it is created when an account is created in godwoken via a deposit request. It uniquely identifies an identity address used on godwoken. When a user deposits funds to godwoken and successfully creates an account, the polyjuice address for the identity address will be created. The user can then use identity address to uniquely locate the polyjuice address on this very godwoken chain.

We do understand the hassles adding a new address concept here, we believe the benefits here, will outweigh the disadvantages here, we also provides utilities that can medicate the problem here:

1. For each supported address formats, we will provide helper functions to convert between polyjuice addresses, and the identity addresses.
2. Transaction signing is completely taken care of, so one can only sign the transactions using identity addresses from each wallet.
3. All the RPCs will be revisited, so when we know a parameter is an address(such as `data` in `eth_getStorageAt`, or `to` in `eth_call`), we will perform the address transalation automatically.
4. We have patched `ecrecover` pre-compiled contract to return polyjuice address format. This way polyjuice will only need to deal with polyjuice addresses, no identity addresses will be used internally.

Based on those changes, we have the following suggestions when building a polyjuice apps:

1. Your existing utilities for deploying Ethereum contracts should continue to work. Polyjuice addresses will be returned as Ethereum contract addresses. Contracts are not considered to be user accounts, they don't have corresponding identity addresses.
2. We do recommend that identity addresses to be used as widely as possible in the UI side of the app, so users can see the same address in the app, as well as their wallet.
3. When you are making a contract call and use an address in one of the call parameters, you will need to use provided RPCs to transform identity addresses into polyjuice addresses, then pass the polyjuice address to the contract call as parameters.
4. When you need to query the on-chain storage to get an address, you might need to make RPC calls to convert the polyjuice addresses back to identity addresses so as to present to the users.

Basically, we recommend using identity addresses as much as possible, and only make the conversion to identity addresses when absolutely necessary.
